отвечаю развёрнуто и по делу. Ниже — качественный, **полный** разбор статьи _Agentic AI Frameworks. Architectures, Protocols, and Design Challenges_ (2025) с точными ссылками на места в тексте, плюс расширение там, где авторы оставили лакуны.

---

# 1) Что именно делает статья и зачем она нужна

Авторы дают системный обзор Agentic AI как класса систем на базе LLM, где агенты демонстрируют целенаправленную автономию, контекстное рассуждение и многоагентную координацию. Работа сравнивает ведущие фреймворки (CrewAI, LangGraph, AutoGen, Semantic Kernel, Agno, Google ADK, MetaGPT) по архитектуре, коммуникации, памяти, guardrails и степени готовности к сервисно-ориентированным экосистемам; отдельно анализируются современные протоколы взаимодействия агентов (MCP, A2A, ANP, ACP, Agora). Это позиционируется как «опорная таксономия» + направления будущих исследований для масштабируемости и интероперабельности.

Контекст: Agentic AI — это сдвиг по сравнению с классическим MAS: агенты теперь LLM-центричны, работают в открытых средах, используют инструменты/API, сотрудничают и решают длинные задачи. Прямо в введении подчеркивается разрыв между бурным ростом экосистемы и отсутствием систематического понимания различий фреймворков.

Исследовательские вопросы (RQ1–RQ4) организуют весь обзор: эволюция агента; какие фреймворки и как реализуют агентные/МАS-парадигмы; сравнение коммуникации/памяти/оркестрации/guardrails; готовность к сервисным экосистемам.

---

# 2) Эволюция агента (RQ1): от BDI к LLM-агентам

Существенный сдвиг: от детерминированной логики и статических правил (BDI/ACL/KQML) — к вероятностному, контекстно-чувствительному планированию с саморефлексией, динамическому выбору инструментов и расширенной памяти. Табличное сравнение в статье фиксирует: управление целями становится многоуровневым, архитектуры — модульными (LLM + память + инструменты + роли), коммуникация — событийной, а память — интегрированной.

Архитектурный каркас современных агентов авторы связывают с ReAct/Reflexion-подобными петлями рассуждение→действие→обновление контекста, где LLM выступает «двигателем» планирования, диалога и вызова инструментов.

---

# 3) Протоколы взаимодействия (ядро RQ3): где сейчас «узкое горлышко»

Сравнение MCP / ACP / A2A / ANP / Agora даёт ясную картину:

- **Форматы:** MCP/A2A — JSON-RPC; ANP — JSON-LD; ACP — goal-ориентированный JSON; Agora — надслой с Protocol Documents (PD) и NL-семантикой.
    
- **Дискавери:** от ручного и «карточек агента» до JSON-LD-описаний и обмена PD.
    
- **Транспорты:** HTTP/StdIO/SSE, доминирует HTTP.
    
- **Назначение:** от LLM-tool интеграции до enterprise-оркестрации и децентрализованных рынков агентов.  
    Ключевой вывод авторов: тренд к сервисной интероперабельности есть, но семантическая разнородность (перформативы vs goal/PD) тормозит «бесшовность», а стандарты «контрактов услуг» уровня WSDL для агентов ещё незрелы.
    

**Что это означает на практике.** Даже если фреймворк поддерживает, скажем, MCP, вам всё равно придётся мэппить «намерения/артефакты/контекст» при общении с A2A/ANP-агентами: контрактов и общих семантик недостаточно, а значит, нужны промежуточные «шлюзы» (gateway/bridge) и регистры способностей. Эти импликации прямо вытекают из вывода статьи о фрагментации и недостающих стандартах контрактов.

---

# 4) Фреймворки (RQ2/RQ3): кто на что способен

Авторы каталожируют роль-ориентированные и графовые платформы: AutoGen (мультиагентные диалоги/кооперация), CrewAI (роли и делегирование), MetaGPT (команда разработки), LangGraph (состояния/графы/трассируемость), Semantic Kernel (планировщики/скиллы для enterprise), Agno (декларативность/прозрачность), Google ADK (масштабируемые многоагентные пайплайны), LlamaIndex (запросы к данным/индексам).

При этом авторы подчёркивают «общий набор узлов»: LLM как мотор рассуждений (подкреплён few/one-shot/CoT), инструменты, память, guardrails как слой безопасности/валидации. Это — не просто перечисление, а тезис о конвергенции архитектур.

---

## 4.1 Память: не просто «контекст», а типизированная подсистема

Статья даёт чёткую типологию: short-term, long-term, semantic, procedural, episodic. Таблица по фреймворкам показывает, где какая поддержка встроена: напр., у CrewAI — богатая агентная память (в т.ч. сущностная/контекстная), у LangGraph — сохранение состояния узлов, у Semantic Kernel — расширяемые модули памяти со связкой с планировщиком/скиллами; LlamaIndex — retrieval из индексов; AutoGen/Google ADK — разделяемый контекст между агентами.

Авторы отдельно проговаривают, как эта память реально используется: LangGraph сохраняет состояние в графах; OpenAI SDK — сессионная память; CrewAI — память на уровне роли и делегации; AutoGen — перенос/персистирование памяти между ролями.

## 4.2 Guardrails: где сильные/слабые места сегодня

Сильнее всего встроены в AutoGen (валидаторы/ретраи), LangGraph (проверки на уровне узлов/потоков), Agno (ранний trust-layer), OpenAI SDK (схемы/валидаторы). Частичные/точечные — у CrewAI/MetaGPT/Google ADK; у LlamaIndex/Semantic Kernel проверки в отдельных стадиях; у SmolAgents — по сути отсутствуют. Итог авторов: без внешней логики/ручной настройки пока не обойтись; нужен стандартизируемый модульный «safety-layer».

---

# 5) Применения: уже не только демо

Авторы приводят отрасли, где многоагентные фреймворки уже применяются: финансы (управление риском/аномалии/стратегии на основе коллаборации агентов), транспорт (модульный трафик-менеджмент на LangGraph), туризм (автопланирование путешествий на CrewAI). Но при этом признают: широкое внедрение тормозят непрозрачность архитектур и отсутствие стандартизации, слабые протоколы координации и дефицит стандартных API для коллаборации.

---

# 6) Service-oriented взгляд (RQ4): кто готов к ААS (Agent-as-a-Service)

Таблица совместимости с сервисными функциями (дискавери/паблишинг/композиция) даёт прагматичный «срез»:

- **Semantic Kernel, Google ADK** — сильные в композиции (планировщики/облако), но без «нативных» примитивов сервисности; опора на внешние регистры/оркестраторы.
    
- **LangGraph** — удобен для композиции (машина состояний), дискавери достижим через расширения.
    
- **CrewAI/AutoGen/Agno/MetaGPT** — хороши в планировании/кодогенерации, но без внешнего реестра способностей сложно встраиваться в динамические сервисные экосистемы.
    

Важный добавочный слой — сопоставление с W3C-семейством (WSDL/BPEL/WS-Policy/WS-Security/WS-Coordination/WS-Agreement): сейчас есть только **частичные аналогии** (JSON-schema как «псевдо-WSDL», BPEL-подобные сценарии у AutoGen, policy/токены/координация/квазисоглашения QoS — точечно по фреймворкам). Авторы прямо говорят: черты появляются, но стандартизированной, совместимой реализации пока нет.

---

# 7) Ограничения (раздел V) и инженерные следствия

1. **Жёсткие роли** (планировщик/исполнитель/кодер) — плохо адаптируются на ходу (MetaGPT/CrewAI). Нужна роль-как-политика с динамической переактивацией.
    
2. **Нет runtime-дискавери** — взаимодействия статичны; авторы рекомендуют реестры агентов/скиллов для динамического само-соединения.
    
3. **Риск исполнения кода** — необходима песочница/допуск только «чистых» функций.
    
4. **Интероп-зазоры** — фреймворки в «силоcах»; разумный путь — обёртка агентов как сервисов (REST) **плюс** протокольный обмен для сложной коллаборации.
    

---

# 8) Что авторы недоговорили — и чем разумно расширить (без «воды»)

**(а) Контракты и дискавери.** Статья убедительно аргументирует нужду в «WSDL-для-агентов», но не даёт минимально необходимого контракта. На основе выводов о фрагментации уместно ввести _минимальный «конверт» сообщения_ для мостов между MCP/A2A/ANP: `id/in_reply_to/trace`, `sender/receiver/ttl/priority/auth`, `intent (performative|goal|task)`, `context (memory_keys/policy/safety)`, `artifacts (тип + URI/CID)`, `errors/SLA`. Это напрямую отвечает на разнородность семантик и дефицит сервисных контрактов, описанные авторами.

**(б) Guardrails как «safety-mesh».** Авторы фиксируют фрагментарность; логичный, вытекающий из текста план — трёхслойный: **ex-ante** (политики/доступ/запретные инструменты), **in-flight** (лимиты шагов/бюджеты/валидаторы схем/детект петель), **ex-post** (аудит/пост-фильтрация/двухфакторные действия). Это операционализирует общий вывод о потребности в модульном safety-слое.

**(в) Память как продуктовая подсистема.** Статья даёт типологию и распределение по фреймворкам; чтобы идти к продакшену, нужны политики хранения/TTL/вытеснения и разграничение доверия (что можно «переиспользовать» семантически, а что нет). Это естественное развитие раздела о памяти/эпизодах/семантическом кэше.

**(г) Метрики/бенчмарки.** Авторы прямо призывают к стандартам сравнения. Логичное продолжение — задать TSR/Time-to-Goal/Cost-per-Goal, Tool-Use Efficacy, Loop-Free Rate, Safety Incidents, Interop-Score (доля успешных диалогов между разнородными протоколами). Это непосредственно следует из заключения о нужде в воспроизводимых сравнениях.

---

# 9) Практические выводы «для внедрения» (следуют из текста)

**Когда какой фреймворк:**

- **Нужна трассируемая, детерминированная оркестрация** → LangGraph (машина состояний).
    
- **Диалоговая кооперация нескольких ролей** → AutoGen/CrewAI.
    
- **Корпоративная интеграция/планирование/скиллы** → Semantic Kernel.
    
- **Масштабные пайплайны в облаке (эксперим.)** → Google ADK.
    

**Чтобы пройти «порог в прод»:**

1. **Реестр способностей** (capability registry) и легковесный **мост протоколов**. Это непосредственно адресует «нет runtime-дискавери».
    
2. **Безопасное исполнение** (sandbox/белые списки). Это прямо покрывает предупреждение авторов.
    
3. **Наблюдаемость/метрики** (TSR/Cost/Loops/Safety). Это конкретизирует их призыв к стандартизации оценок.
    

---

# 10) Сильные стороны и объективные ограничения самой статьи

**Сильные стороны:**

- Чёткая постановка RQ1–RQ4 и логика изложения.
    
- Сопоставление протоколов с ясными выводами о фрагментации семантик и недостаче контрактов.
    
- Взгляд через призму сервис-ориентированной архитектуры + таблицы готовности и W3C-аналогий.
    

**Ограничения (самими авторами признаны/вытекают):**

- Нет единых бенчмарков/метрик — сравнения остаются качественными.
    
- Нет «референс-контракта» для интеропа — сформулирована только потребность.
    
- Внедрение в домены тормозится отсутствием стандартов: это зафиксировано в разделе про сервис-взгляд и ограничения.
    

---

## Концентрат «что унести с собой»

1. **Agentic AI ≠ просто «LLM + инструменты»**. Это целостная система: LLM-рассуждения, память нескольких типов, координация, протоколы и guardrails — всё важно одинаково.
    
2. **Интероперабельность — центральная проблема**. Без общих контрактов/семантик и discovery-механизмов агентные экосистемы будут фрагментированы.
    
3. **Движение к Agent-as-a-Service** уже началось (частичные WSDL/BPEL-аналогии), но до производственной «стандартизации» ещё далеко.
    

---

Если хотите, сделаю из этого разбора два прикладных артефакта (по статье, без «воды»):

- **матрицу выбора фреймворка** под ваш use-case (1 страница);
    
- **минимальный контракт межагентного сообщения** (полевая схема + пример мэппинга MCP↔A2A↔ANP), который закрывает главный разрыв, обозначенный авторами.